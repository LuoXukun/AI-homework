#include <bang_sigmoid_sample.h>
#include <kernel.h>
#
__nram__ char NRAM_BUFFER[MAX_NRAM_SIZE];

// =========================================
// 从这里开始实现BANG sigmoid kernel
// =========================================

template<typename T>
__mlu_device__ void bang_sigmoid(T *dst, const T *src, const int N) {
    for (int i = 0; i < N; ++i) {
        dst[i] = 1 / (1 + exp(-src[i]));
    }
}

template<typename T>
__mlu_global__ void bang_sigmoid_kernel(T *d_dst, T *d_src, int N) {
  const int NRAM_LIMIT_SIZE = FLOOR_ALIGN(MAX_NRAM_SIZE / 2, 64);
  int nram_limit = NRAM_LIMIT_SIZE / sizeof(T);
  // __bang_printf("nram_limit=%d \n", nram_limit);
  nram_limit = 12;

  // 对列数据切分
  int32_t num_per_core = N / taskDim; // 12 / n
  int32_t repeat = num_per_core / nram_limit;
  int32_t rem = num_per_core % nram_limit;

  // =============
  //__bang_printf("NRAM_LIMIT=%d, rem=%d \n", NRAM_LIMIT_SIZE, rem);
  //__bang_printf("repeat=%d, num_per_core=%d \n", repeat, num_per_core);

  T *d_input_per_task = d_src + taskId * nram_limit;
  T *d_output_per_task = d_dst + taskId * nram_limit;
  T *nram_out = (T *)NRAM_BUFFER;
  T *nram_in = (T *)(NRAM_BUFFER + NRAM_LIMIT_SIZE);

  const int align_rem = CEIL_ALIGN(rem, 64);
  //__bang_printf("align_rem=%d \n", align_rem);

  int i = 0;
  for (; i < repeat; i++) {
    // TODO: 请补充拷贝方向
    __memcpy_async(nram_in, d_input_per_task + i * nram_limit, 
                    NRAM_LIMIT_SIZE, GDRAM2NRAM);
    __sync_io();
    // TODO: 请补充BANG的sigmoid函数
    bang_sigmoid(nram_out, nram_in, nram_limit);
    __sync_compute();

    // TODO: 请补充拷贝方向
    __memcpy_async(d_output_per_task + i * nram_limit, nram_out,
                   NRAM_LIMIT_SIZE, NRAM2GDRAM);

    __sync_io();
  }

  // 实际上，对于那个 3 * 4 的矩阵来说，仅仅会运行到这一块，前面那一块循环是不会运行的。
  if (rem > 0) {
    // TODO: 请补充拷贝方向
    __memcpy_async(nram_in, d_input_per_task + i * nram_limit,
                   rem * sizeof(T), GDRAM2NRAM);
    __sync_io();
    // TODO: 请补充BANG的sigmoid函数
    bang_sigmoid(nram_out, nram_in, 12);
    __sync_compute();
    // TODO: 请补充拷贝方向
    __memcpy_async(d_output_per_task + i * nram_limit, nram_out,
                   rem * sizeof(T), NRAM2GDRAM);

    __sync_io();
  }
}

template<typename T>
void bang_sigmoid_kernel_entry(cnrtQueue *queue, T *d_dst, T *d_src,
                               int elem_count) {
  cnrtDim3_t dim = {1, 1, 1};
  int taskDims = dim.x * dim.y * dim.z;
  // TODO: 请补充Kernel函数类型
  cnrtFunctionType_t c = CNRT_FUNC_TYPE_BLOCK;
  if (elem_count < taskDims) {
    dim.x = 1;
    dim.y = 1;
  }
  // TODO: 请补充Kernel函数的调用
  bang_sigmoid_kernel<<<dim, c, queue>>>(d_dst, d_src, elem_count);;
  cnrtQueueSync(queue);
}


template<typename T>
void bang_sigmoid_sample(T *h_dst, T *h_src, const int elem_count) {

  T *d_src, *d_dst;
  cnrtQueue_t queue;
  cnrtQueueCreate(&queue);
  cnrtRet_t ret;
  ret =
      cnrtMalloc(reinterpret_cast<void **>(&d_src), elem_count * sizeof(T));
  ret =
      cnrtMalloc(reinterpret_cast<void **>(&d_dst), elem_count * sizeof(T));

  ret = cnrtMemcpy(d_src, h_src, elem_count * sizeof(T),
                   CNRT_MEM_TRANS_DIR_HOST2DEV);

  bang_sigmoid_kernel_entry(queue, d_dst, d_src, elem_count);
  cnrtQueueSync(queue);
  // TODO: 请补充Host和Device间的内存拷贝方向
  ret = cnrtMemcpy(h_dst, d_dst, elem_count * sizeof(T),
                   CNRT_MEM_TRANS_DIR_DEV2HOST);

  ret = cnrtQueueDestroy(queue);
}
template void bang_sigmoid_sample(float*, float*, int);
template void bang_sigmoid_kernel_entry(cnrtQueue *, float *, float *, int);
